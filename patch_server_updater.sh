#!/bin/bash
################################################################################
# This script is released under MIT Licence by Fabien PONCET
# Fabien PONCET <fabien.poncet@jetpulp.fr>
# Shell Script with getopts parsing
#
# Name:  patch_server_updater.sh
#
# Description:  This script is used to generate a config file from a first
#               definition push based on brysontyrrell work (github) and can be
#               use to add a new version for this patch with a manual call or a
#               scripted one. (Ex: we parse a changlog website page to get all
#               existed version for an app to keep Jamf Pro updated)
#
#               init - create the config file for add command and push
#                      to the patch Server
#
#               add  - push a new app version based on the config file generated
#                      by init
#
#
# @brysontyrrell : https://github.com/brysontyrrell/Patch-Starter-Script
#                  https://github.com/brysontyrrell/PatchServer
#
#
# Authors:  Fabien PONCET
# Created:  2019-03-19
# Last Modified:  2019-03-19
# Version:  1.0
################################################################################


init () {
  SCRIPT_DIR=$(pwd)
  SCRIPT_NAME=$(basename "$0")

  #INIT COMMAND mandatory variables
  unset j_flag
  unset u_flag
  unset o_flag

  #INIT add mandatory variables
  unset d_flag
  unset v_flag
  unset o_flag
  unset c_flag
}


param_handler () {
# INIT COMMAND HANDLER
  if [ "$1" == "init" ]; then
    OPTIND=2
    while getopts "j:u:o:h" param; do
      case "${param}" in
        j)
          echo "JSON : $OPTARG"
          JSON_INPUT="$OPTARG"
          j_flag=true
          ;;
        u)
          echo "URL : $OPTARG"
          URL_INPUT="$OPTARG"
          u_flag=true
          ;;
        o)
          echo "CONFIG : $OPTARG"
          CONFIG_OUT_INPUT="$OPTARG"
          o_flag=true
          ;;
        h | *)
          usage_init
          exit 0
          ;;
      esac
    done
    if [ $OPTIND -eq 2 ]; then
      echo "No options were passed"
      usage_init
      exit 0
    elif [ ! "$j_flag" -o ! "$u_flag" -o ! "$o_flag" ]; then
    echo "Missing mandatory options"
    usage_init
    exit 0
  fi
# ADD COMMAND HANDLER
  elif [ "$1" == "add" ]; then
    OPTIND=2
    while getopts "d:v:o:c:h" param; do
      case "${param}" in
        d)
          echo "DATE : $OPTARG"
          DATE_INPUT="$OPTARG"
          d_flag=true
          ;;
        v)
          echo "VERSION : $OPTARG"
          VERSION_INPUT="$OPTARG"
          v_flag=true
          ;;
        o)
          echo "MIN_OS : $OPTARG"
          MIN_OS_INPUT="$OPTARG"
          o_flag=true
          ;;
        c)
          echo "CONFIG : $OPTARG"
          CONFIG_IN_FILE_INPUT="$OPTARG"
          c_flag=true
          ;;
        h | *)
          usage_add
          exit 0
          ;;
      esac
    done
    if [ $OPTIND -eq 2 ]; then
      echo "No options were passed"
      usage_add
      exit 0
    elif [ ! "$d_flag" -o ! "$v_flag" -o ! "$o_flag" -o ! "$c_flag" ]; then
      echo "Missing mandatory options"
      usage_add
      exit 0
    fi
  else
  # NO COMMAND
    usage_init
    usage_add
    exit 0
  fi
}


usage_init() {
echo -n "
$SCRIPT_NAME init -j [TEMPLATE_FILE] -u [PATCH_SERVER_URL] -o [OUTPUT_FILE_CONFIG]

     -j, json patch definition (generated with patchstarter.py - https://github.com/brysontyrrell/Patch-Starter-Script) [Required]
     -u, url of the patch server (like https://127.0.0.1:5000) [Required]
     -o, output config auto generated file path [Required]
"
}


usage_add () {
echo -n "
$SCRIPT_NAME add -d [DATE] -v [VERSION] -o [OS_MIN] -c [CONFIG_FILE]

      -d, date for the new version, format (YYYY-MM-DD) [Required]
      -v, version name [Required]
      -o, min Mac OS version [Required]
      -c, config file generated by $SCRIPT_NAME init [Required]
"
}


clear_tmp () {
  if [ ${FIXED_APP_NAME_ID} ]; then
    rm -f /tmp/${FIXED_APP_NAME_ID}*
  fi
}


################################################################################
# INIT COMMAND FUNCTIONS
################################################################################


push_patch_def () {
	if [ -s $3 ]; then
		echo "$3 already exist, delete it if you want to repush a new patch definition."
		exit 0
	else
		TEMP_FIXED_APP_NAME_ID=$(cat $1 | grep -o '"id":.*' | cut -d '"' -f4)
		if [ -z "$TEMP_FIXED_APP_NAME_ID" ]; then
			echo "Name ID field is missing in the config file"
			exit 0
		fi

		TEMP_FIXED_APP_NAME=$(cat $1 | grep -o '"appName":.*' | cut -d '"' -f4)
		if [ -z "$TEMP_FIXED_APP_NAME" ]; then
			echo "Name .app field is missing in the config file"
			exit 0
		fi

		TEMP_FIXED_NAME=$(cat $1 | grep -o '"name":.*' | cut -d '"' -f4)
		if [ -z "$TEMP_FIXED_NAME" ]; then
			echo "Name field is missing in the config file"
			exit 0
		fi

		TEMP_FIXED_BUNDLE_ID=$(cat $1 | grep -o '"bundleId":.*' | cut -d '"' -f4)
		if [ -z "$TEMP_FIXED_BUNDLE_ID" ]; then
			echo "Bundle ID field is missing in the config file"
			exit 0
		fi

		echo "Input JSON checked, seems to be OK, checking patch server access ..."


		TEMP_PATCH_SERVER_URL=$(echo $2 | cut -d '/' -f1-3)
		if [ -z "$(curl -L -m 15 -s -X GET $TEMP_PATCH_SERVER_URL | grep "<title>Patch Server</title>")" ]; then
			echo "Sorry, can't connect to the patch server at $TEMP_PATCH_SERVER_URL"
			exit 0
		fi

		echo "Ok, $TEMP_PATCH_SERVER_URL is recheable, trying to push JSON file to the API."

		response_check=$(curl -s -m 60 -X POST $TEMP_PATCH_SERVER_URL/api/v1/title -d @"$1" -H 'Content-Type: application/json')
		if [ -z "$(echo ${response_check} | grep '^{ "database_id":')" ]; then
			echo "Push failed, check api response here :"
			echo "$response_check"
			exit 0
		fi

		echo "Push success, $3 will be generate soon"

		cat > $3 <<-EOF
		FIXED_APP_NAME_ID="$TEMP_FIXED_APP_NAME_ID"
		FIXED_APP_NAME="$TEMP_FIXED_APP_NAME"
		FIXED_NAME="$TEMP_FIXED_NAME"
		FIXED_BUNDLE_ID="$TEMP_FIXED_BUNDLE_ID"

		PATCH_SERVER_URL="$TEMP_PATCH_SERVER_URL"
		PATCH_SERVER_API_URL_GET_VERSION="$TEMP_PATCH_SERVER_URL/jamf/v1/patch/$TEMP_FIXED_APP_NAME_ID"
		PATCH_SERVER_API_URL_POST_VERSION="$TEMP_PATCH_SERVER_URL/api/v1/title/$TEMP_FIXED_APP_NAME_ID/version"
		EOF

		echo "$3 config file generated !"
		echo "$SCRIPT_NAME [add] will be able to update a new version of $TEMP_FIXED_APP_NAME_ID if you can parse a website and collect informations"
		exit 0
	fi

}


################################################################################
# ADD COMMAND FUNCTIONS
################################################################################
import_env () {
	if [ ! -s $CONFIG_IN_FILE_INPUT ]; then
    echo
    echo "$CONFIG_IN_FILE_INPUT is missing, you need to push patch definition on server with $SCRIPT_NAME [init]"
    usage_add
		exit 0
	else
		source $CONFIG_IN_FILE_INPUT
		echo "$CONFIG_IN_FILE_INPUT imported"
	fi
}


create_json () {
TEMPLATE=$(cat << EOF
{
    "releaseDate": "PLACEHOLDER_DATE",
    "killApps": [
        {
            "appName": "PLACEHOLDER_FIXED_APP_NAME",
            "bundleId": "PLACEHOLDER_FIXED_BUNDLE_ID"
        }
    ],
    "version": "PLACEHOLDER_VERSION",
    "components": [
        {
            "version": "PLACEHOLDER_VERSION",
            "name": "PLACEHOLDER_FIXED_NAME",
            "criteria": [
                {
                    "operator": "is",
                    "and": true,
                    "type": "recon",
                    "name": "Application Bundle ID",
                    "value": "PLACEHOLDER_FIXED_BUNDLE_ID"
                },
                {
                    "operator": "is",
                    "type": "recon",
                    "name": "Application Version",
                    "value": "PLACEHOLDER_VERSION"
                }
            ]
        }
    ],
    "standalone": true,
    "minimumOperatingSystem": "PLACEHOLDER_OS",
    "dependencies": [],
    "reboot": false,
    "capabilities": [
        {
            "operator": "greater than or equal",
            "type": "recon",
            "name": "Operating System Version",
            "value": "PLACEHOLDER_OS"
        }
    ]
}
EOF
)
  data_to_push=$(echo "$TEMPLATE" | sed -e "s/PLACEHOLDER_VERSION/$2/g" | sed -e "s/PLACEHOLDER_DATE/$1/g" | sed -e "s/PLACEHOLDER_OS/$3/g" | sed -e "s/PLACEHOLDER_FIXED_APP_NAME/${FIXED_APP_NAME}/g" | sed -e "s/PLACEHOLDER_FIXED_BUNDLE_ID/${FIXED_BUNDLE_ID}/g" | sed -e "s/PLACEHOLDER_FIXED_NAME/${FIXED_NAME}/g")
}


check_newversion () {
		if [ -z "$(curl -L -m 60 -s ${PATCH_SERVER_API_URL_GET_VERSION} |grep '"version":.*'| cut -d '"' -f4 | grep -m 1 "^${1}$")" ]; then
		echo "New version detected : $1"
		echo "Pushing to patch server ..."
		curl --silent -m 60 --output /dev/null -X POST $PATCH_SERVER_API_URL_POST_VERSION -d "$data_to_push" -H 'Content-Type: application/json'
		echo "Done"
		#slack_alert
	else
		echo "Version already on patch server"
	fi
}



################################################################################
# MAIN
################################################################################


main () {
  init
  param_handler "$@"

  if [ "$1" == "init" ]; then
    push_patch_def "$JSON_INPUT" "$URL_INPUT" "$CONFIG_OUT_INPUT"
    exit 0
  fi

  if [ "$1" == "add" ]; then
  	import_env "$CONFIG_IN_FILE_INPUT"
    create_json "$DATE_INPUT" "$VERSION_INPUT" "$MIN_OS_INPUT"
    check_newversion "$VERSION_INPUT"
  	clear_tmp
    exit 0
  fi
}


main "$@"
